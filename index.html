<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowball Sniper - HD Remaster</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            background-color: #121212;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 95vw;
            height: auto;
            aspect-ratio: 1974/1168;
            max-height: 95vh; 
            
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border: 4px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #2a1d15;
            image-rendering: pixelated;
            cursor: none; 
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 30px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 3px 3px 0 #000;
            font-size: 20px;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .label {
            font-size: 14px;
            color: #ccc;
        }

        .value {
            font-size: 40px;
            color: #ffd700;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.05) 50%,
                rgba(0,0,0,0.05)
            );
            background-size: 100% 4px;
            pointer-events: none;
            opacity: 0.4;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="1974" height="1168"></canvas>
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <div class="hud-item">
            <span class="label">SCORE</span>
            <span class="value" id="score-display">0000</span>
        </div>
        <div class="hud-item" style="align-items: flex-end;">
            <span class="label">TIME</span>
            <span class="value" id="time-display">60</span>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- ASSETS ---
    const bgImg = new Image();
    bgImg.src = 'https://i.imgur.com/ItZx3i7.png';

    const logoImg = new Image();
    logoImg.src = 'https://i.imgur.com/b0AD4hY.png';

    const crosshairImg = new Image();
    crosshairImg.src = 'https://i.imgur.com/JrtG9Ll.png';

    // UI Icons
    const iconHighscore = new Image();
    iconHighscore.src = 'https://i.imgur.com/BB2Cysw.png';
    const iconRetry = new Image();
    iconRetry.src = 'https://i.imgur.com/t2FzJ6S.png';
    const iconMenu = new Image();
    iconMenu.src = 'https://i.imgur.com/NeJWcts.png';

    const snowmanImg = new Image();
    snowmanImg.src = 'https://i.imgur.com/ZUjWUMA.png';

    const santaImg = new Image();
    santaImg.src = 'https://i.imgur.com/O4JEQNl.png';

    const elfImg = new Image();
    elfImg.src = 'https://i.imgur.com/Ebjgseh.png';

    const reindeerImg = new Image();
    reindeerImg.src = 'https://i.imgur.com/7NjMnbn.png';

    const bearAliveImg = new Image();
    bearAliveImg.src = 'https://i.imgur.com/sbiJDNt.png';
    const bearDeadImg = new Image();
    bearDeadImg.src = 'https://i.imgur.com/YwRuc8l.png';

    const dogSleepImg = new Image();
    dogSleepImg.src = 'https://i.imgur.com/rfiGDKY.png';
    const dogAwakeImg = new Image();
    dogAwakeImg.src = 'https://i.imgur.com/spGomDQ.png';

    const treeImg = new Image();
    treeImg.src = 'https://i.imgur.com/8Ax38hR.png';

    const wreathImg = new Image();
    wreathImg.src = 'https://i.imgur.com/n9Cmgy1.png';

    const sillImg = new Image();
    sillImg.src = 'https://i.imgur.com/TpGmLtV.png';

    const fireImg = new Image();
    fireImg.src = 'https://i.imgur.com/JtpFA54.png';

    const loadImages = (urls) => urls.map(src => {
        const img = new Image();
        img.src = src;
        return img;
    });

    const giftImgs = loadImages([
        'https://i.imgur.com/yQLkIGn.png',
        'https://i.imgur.com/8NcF30V.png',
        'https://i.imgur.com/2aqEFuj.png',
        'https://i.imgur.com/Sm1j1SK.png',
        'https://i.imgur.com/V8NiRZY.png'
    ]);

    const frameImgs = loadImages([
        'https://i.imgur.com/aoKffUf.png',
        'https://i.imgur.com/YrMecoJ.png',
        'https://i.imgur.com/O0u0XAO.png',
        'https://i.imgur.com/4zlVUkA.png',
        'https://i.imgur.com/kTgC5aX.png',
        'https://i.imgur.com/oC4Ct9q.png'
    ]);

    const lightImgs = loadImages([
        'https://i.imgur.com/9HECKLv.png',
        'https://i.imgur.com/pIGEzk9.png',
        'https://i.imgur.com/VeZet18.png',
        'https://i.imgur.com/OdCInfr.png',
        'https://i.imgur.com/J6oR4b4.png',
        'https://i.imgur.com/dNvLgX0.png',
        'https://i.imgur.com/AWv5MAq.png',
        'https://i.imgur.com/PaKdrFO.png',
        'https://i.imgur.com/96cHRWm.png',
        'https://i.imgur.com/0BBFJEq.png'
    ]);

    const sockImgs = loadImages([
        'https://i.imgur.com/ipuoMGf.png',
        'https://i.imgur.com/JokSc9E.png',
        'https://i.imgur.com/JtKyxoz.png'
    ]);

    const windowImgs = {
        normal: loadImages([
            'https://i.imgur.com/nPvNZZQ.png', 
            'https://i.imgur.com/U7rdB4u.png', 
            'https://i.imgur.com/WLeB2rG.png', 
            'https://i.imgur.com/hL4DfE2.png'  
        ]),
        broken: loadImages([
            'https://i.imgur.com/xXwbOdk.png', 
            'https://i.imgur.com/fXLheVS.png', 
            'https://i.imgur.com/1G8g2eQ.png', 
            'https://i.imgur.com/VCth7xd.png'  
        ])
    };

    const HIT_FILTERS = [
        'sepia(1) saturate(100) hue-rotate(-50deg) contrast(2)',   // Red
        'sepia(1) saturate(100) hue-rotate(60deg) contrast(2)',    // Green
        'sepia(1) saturate(100) hue-rotate(240deg) contrast(2)',   // Pink
        'sepia(1) saturate(100) hue-rotate(130deg) contrast(2)',   // Turquoise
        'sepia(1) saturate(100) hue-rotate(180deg) contrast(2)',   // Blue
        'sepia(1) saturate(100) hue-rotate(0deg) contrast(2)'      // Yellow
    ];

    const FX_SCALE = 2.5;
    const SCALE = 2.45; 

    // STATE MANAGEMENT
    const STATES = {
        MENU: 'menu',
        PLAYING: 'playing',
        GAMEOVER: 'gameover',
        HIGHSCORE: 'highscore'
    };

    let state = {
        current: STATES.MENU,
        score: 0,
        time: 60,
        shake: 0,
        highscores: [], // {rank: 1, score: 100, name: 'AAA'}
        enteringInitials: false,
        playerInitials: ''
    };

    const mouse = { x: 0, y: 0 };

    let entities = [];
    const particles = [];
    const snowballs = [];

    // --- CLASSES ---

    class Particle {
        constructor(x, y, color, speed = 15, size = 4) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * speed;
            this.vy = (Math.random() - 0.5) * speed;
            this.life = 1.0;
            this.color = color;
            this.size = (Math.random() * size + 2) * FX_SCALE;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.4; 
            this.life -= 0.05;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    class Snowball {
        constructor(targetX, targetY) {
            this.startX = canvas.width / 2;
            this.startY = canvas.height;
            this.x = this.startX;
            this.y = this.startY;
            this.targetX = targetX;
            this.targetY = targetY;
            this.speed = 0.05;
            this.progress = 0;
            this.markedForDeletion = false;
            this.layer = 100;
        }

        update() {
            this.progress += this.speed;
            this.x = this.startX + (this.targetX - this.startX) * this.progress;
            this.y = this.startY + (this.targetY - this.startY) * this.progress;

            if (this.progress >= 1) {
                this.x = this.targetX;
                this.y = this.targetY;
                this.explode();
            }
        }

        explode() {
            this.markedForDeletion = true;
            checkCollision(this.x, this.y);
            for(let i=0; i<8; i++) {
                particles.push(new Particle(this.x, this.y, '#ffffff'));
            }
        }

        draw(ctx) {
            const scale = 1.0 - (this.progress * 0.5); 
            const size = (15 * FX_SCALE) * scale;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Entity {
        constructor(x, y, layer = 0) {
            this.x = x;
            this.y = y;
            this.w = 0;
            this.h = 0;
            this.layer = layer; 
            this.markedForDeletion = false;
            this.isHit = false; 
            this.hitTimer = 0;
            this.collidable = true; 
        }

        getZ() {
            return this.y + this.h;
        }

        draw(ctx) {
            ctx.fillStyle = 'magenta';
            ctx.fillRect(this.x, this.y, this.w, this.h);
        }

        update() {
            if (this.isHit) {
                this.hitTimer--;
                if (this.hitTimer <= 0) this.isHit = false;
            }
        }

        checkHit(mx, my) {
            return (mx >= this.x && mx <= this.x + this.w &&
                    my >= this.y && my <= this.y + this.h);
        }

        onHit() { }
    }

    // --- UI ENTITIES (Buttons) ---
    class ButtonTarget extends Entity {
        constructor(x, y, text, action) {
            super(x, y, 100); 
            this.text = text;
            this.action = action;
            this.w = 600; 
            this.h = 100;
            this.x = x - this.w/2; 
        }

        draw(ctx) {
            ctx.save();
            
            if (this.isHit) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x, this.y, this.w, this.h);
            } 
            
            ctx.fillStyle = this.isHit ? '#ff0044' : '#ffd700'; 
            ctx.font = '50px "Press Start 2P"'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (!this.isHit) {
                ctx.shadowColor = "black";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
            }
            
            ctx.fillText(this.text, this.x + this.w/2, this.y + this.h/2);

            ctx.restore();
        }

        onHit() {
            this.isHit = true;
            this.hitTimer = 5;
            for(let i=0; i<20; i++) particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, '#ffd700', 20));
            setTimeout(() => {
                this.markedForDeletion = true;
                this.action();
            }, 200);
        }
    }

    class ImageButtonTarget extends Entity {
        constructor(x, y, img, action) {
            super(x, y, 100);
            this.img = img;
            this.action = action;
            this.w = 120; // Assume manageable size, will update on load
            this.h = 120;
            this.x = x - this.w/2;
            this.initialized = false;
        }

        update() {
            super.update();
            if (!this.initialized && this.img.complete && this.img.naturalWidth > 0) {
                // Use natural size or scale a bit if needed
                // For icons, let's keep them reasonable. 
                // Assuming the pngs are sized for the game (~100-150px)
                this.w = this.img.naturalWidth;
                this.h = this.img.naturalHeight;
                this.x = this.x + 60 - this.w/2; // Re-center based on new width
                this.initialized = true;
            }
        }

        draw(ctx) {
            if (!this.initialized) return;
            ctx.save();
            if (this.isHit) {
                ctx.filter = 'brightness(100) sepia(1) hue-rotate(-50deg) saturate(5)'; // Red flash
            }
            // Add shadow
            if (!this.isHit) {
                ctx.shadowColor = "black";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
            }
            ctx.drawImage(this.img, this.x, this.y, this.w, this.h);
            ctx.restore();
        }

        onHit() {
            this.isHit = true;
            this.hitTimer = 5;
            for(let i=0; i<20; i++) particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, '#ffffff', 15));
            setTimeout(() => {
                this.markedForDeletion = true;
                this.action();
            }, 200);
        }
    }

    // --- PROPS ---

    class SimpleProp extends Entity {
        constructor(img, x, y, layer, onHitCallback) {
            super(x, y, layer); 
            this.img = img;
            this.onHitCallback = onHitCallback;
            this.initialized = false;
        }

        update() {
            super.update();
            if (!this.initialized && this.img.complete && this.img.naturalWidth > 0) {
                this.w = this.img.naturalWidth;
                this.h = this.img.naturalHeight;
                this.initialized = true;
            }
        }

        onHit() {
            if (!this.onHitCallback) return; 
            this.markedForDeletion = true; 
            state.score += 15;
            updateUI();
            this.onHitCallback(this.x, this.y, this.w, this.h);
        }

        draw(ctx) {
            if (this.initialized) {
                ctx.drawImage(this.img, this.x, this.y, this.w, this.h);
            }
        }
    }
    
    class Fire extends Entity {
        constructor() {
            super(832, 657, 2); 
            this.img = fireImg;
            this.initialized = false;
            this.dying = false;
        }

        update() {
            super.update();
            if (!this.initialized && this.img.complete && this.img.naturalWidth > 0) {
                this.w = this.img.naturalWidth;
                this.h = this.img.naturalHeight;
                this.initialized = true;
            }

            if (this.dying && this.hitTimer <= 0) {
                this.markedForDeletion = true;
                 for(let k=0; k<12; k++) particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, '#555555', 6, 6));
            }
        }

        onHit() {
            if (this.dying) return;
            state.score += 15;
            updateUI();
            
            this.isHit = true;
            this.hitTimer = 6; 
            this.dying = true;
        }

        draw(ctx) {
            if (!this.initialized) return;
            
            ctx.save();
            
            if (this.isHit) {
                 ctx.filter = 'sepia(1) saturate(100) hue-rotate(0deg) contrast(2)';
            }

            const time = Date.now() / 150; 
            const sliceHeight = 2; 
            
            for (let i = 0; i < this.h; i += sliceHeight) {
                const xOffset = Math.sin(time + (i * 0.05)) * 3; 
                const h = Math.min(sliceHeight, this.h - i);
                
                ctx.drawImage(
                    this.img, 
                    0, i, this.w, h,           
                    this.x + xOffset, this.y + i, this.w, h 
                );
            }
            
            ctx.restore();
        }
    }
    
    class WindowPane extends Entity {
        constructor(normalImg, brokenImg, x, y) {
            super(x, y, 2);
            this.normalImg = normalImg;
            this.brokenImg = brokenImg;
            this.isBroken = false;
            this.initialized = false;
        }
        
        update() {
            super.update();
            if (!this.initialized && this.normalImg.complete && this.normalImg.naturalWidth > 0) {
                this.w = this.normalImg.naturalWidth;
                this.h = this.normalImg.naturalHeight;
                this.initialized = true;
            }
        }
        
        onHit() {
            if (!this.isBroken) {
                this.isBroken = true;
                state.score += 15;
                updateUI();
                for(let k=0; k<15; k++) particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, '#a8e6cf', 12, 3));
            }
        }
        
        draw(ctx) {
            if (!this.initialized) return;
            const img = this.isBroken ? this.brokenImg : this.normalImg;
            if (img.complete && img.naturalWidth > 0) {
                ctx.drawImage(img, this.x, this.y, this.w, this.h);
            }
        }
    }
    
    class Wreath extends Entity {
         constructor() {
            super(830, 146, 3); 
            this.img = wreathImg;
            this.initialized = false;
            this.shakeOffset = 0;
            this.hasGivenPoints = false;
        }

        update() {
            super.update();
            if (this.shakeOffset !== 0) {
                this.shakeOffset = -this.shakeOffset * 0.8;
                if (Math.abs(this.shakeOffset) < 1) this.shakeOffset = 0;
            }
            if (!this.initialized && this.img.complete && this.img.naturalWidth > 0) {
                this.w = this.img.naturalWidth;
                this.h = this.img.naturalHeight;
                this.initialized = true;
            }
        }

        onHit() {
            this.shakeOffset = 5;
            this.isHit = true;
            this.hitTimer = 10;
            if (!this.hasGivenPoints) {
                this.hasGivenPoints = true;
                state.score += 15;
                updateUI();
            }
        }

        draw(ctx) {
            if (!this.initialized) return;
            
            ctx.save();
            ctx.translate(this.shakeOffset, 0);
            if (this.isHit) {
                 ctx.filter = 'sepia(1) saturate(100) hue-rotate(-50deg) contrast(2)';
            }
            ctx.drawImage(this.img, this.x, this.y, this.w, this.h);
            ctx.restore();
        }
    }

    class SnowTank extends Entity {
        constructor() {
            const x = 1375;
            const y = 245;
            const w = 1828 - 1375; 
            const h = 582 - 245;   
            
            super(x, y, 2.5);
            this.w = w;
            this.h = h;
            this.collidable = false; 
            
            this.flakes = [];
            for(let i=0; i<100; i++) {
                this.flakes.push(this.createFlake(true));
            }
        }

        createFlake(randomY = false) {
            return {
                x: Math.random() * this.w,
                y: randomY ? Math.random() * this.h : -10, 
                size: (Math.random() * 2 + 1) * FX_SCALE,
                speed: (Math.random() * 1 + 0.5) * FX_SCALE * 0.5,
                swayOffset: Math.random() * Math.PI * 2,
                swaySpeed: (Math.random() * 0.02 + 0.01)
            };
        }

        update() {
            const time = Date.now();
            
            for (let f of this.flakes) {
                f.y += f.speed;
                f.x += Math.sin(time * 0.002 + f.swayOffset) * 0.5 + 0.2;

                if (f.y > this.h) {
                    f.y = -10;
                    f.x = Math.random() * this.w;
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(this.x, this.y, this.w, this.h);
            ctx.clip(); 

            ctx.fillStyle = '#ffffff';
            for (let f of this.flakes) {
                ctx.fillRect(this.x + f.x, this.y + f.y, f.size, f.size);
            }

            ctx.restore();
        }
    }

    class Tree extends Entity {
        constructor() {
            super(116, 233, 0); 
            this.shakeOffset = 0;
            this.hasGivenPoints = false;
        }

        update() {
            super.update();
            if (this.shakeOffset !== 0) {
                this.shakeOffset = -this.shakeOffset * 0.8;
                if (Math.abs(this.shakeOffset) < 1) this.shakeOffset = 0;
            }
            if (treeImg.complete && treeImg.naturalWidth > 0) {
                this.w = treeImg.naturalWidth;
                this.h = treeImg.naturalHeight;
            }
        }

        onHit() {
            this.shakeOffset = 15;
            if (!this.hasGivenPoints) {
                this.hasGivenPoints = true;
                state.score += 15;
                updateUI();
                for(let i=0; i<10; i++) {
                    particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, '#2d6e32'));
                }
            } else {
                 for(let i=0; i<3; i++) {
                    particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, '#2d6e32'));
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.shakeOffset, 0);
            if (treeImg.complete && treeImg.naturalWidth > 0) {
                ctx.drawImage(treeImg, this.x, this.y, this.w, this.h);
            } else {
                ctx.fillStyle = '#0f441e';
                ctx.fillRect(this.x, this.y, 200, 400);
            }
            ctx.restore();
        }
    }

    class Gift extends Entity {
        constructor(index, startX, topY, img) {
            super(startX, 0, 1); 
            this.index = index;
            this.topY = topY;
            this.img = img;
            this.initialized = false;
            this.color = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff'][index];
        }

        update() {
            super.update();
            if (!this.initialized && this.img.complete && this.img.naturalWidth > 0) {
                this.w = this.img.naturalWidth;
                this.h = this.img.naturalHeight;
                this.y = this.topY;
                this.initialized = true;
            }
        }

        onHit() {
            state.score += 15;
            updateUI();
            this.markedForDeletion = true;
            const gridSize = 6;
            const cols = this.w / gridSize;
            const rows = this.h / gridSize;
            for(let r=0; r<rows; r+=2) {
                for(let c=0; c<cols; c+=2) {
                    particles.push(new Particle(
                        this.x + c * gridSize, 
                        this.y + r * gridSize, 
                        this.color,
                        8, 4
                    ));
                }
            }
        }

        draw(ctx) {
            if (this.initialized) {
                ctx.drawImage(this.img, this.x, this.y, this.w, this.h);
            }
        }
    }

    class Bear extends Entity {
        constructor() {
            super(1700, 900, 7); 
            this.alive = true;
            this.shakeOffset = 0;
            this.targetX1 = 1760;
            this.targetY1 = 950; 
            this.targetX2 = 1770;
            this.targetY2 = 937;
            this.initialized = false;
        }

        update() {
            super.update();
            if (this.shakeOffset !== 0) {
                this.shakeOffset = -this.shakeOffset * 0.8;
                if (Math.abs(this.shakeOffset) < 1) this.shakeOffset = 0;
            }
            let img = this.alive ? bearAliveImg : bearDeadImg;
            if (img.complete && img.naturalWidth > 0) {
                this.w = img.naturalWidth;
                this.h = img.naturalHeight;
                const targetX = this.alive ? this.targetX1 : this.targetX2;
                const targetY = this.alive ? this.targetY1 : this.targetY2;
                this.x = targetX - this.w;
                this.y = targetY - this.h;
                this.initialized = true;
            }
        }

        onHit() {
            this.shakeOffset = 15;
            this.isHit = true;
            this.hitTimer = 10;
            if (this.alive) {
                this.alive = false;
                state.score += 15;
                updateUI();
                for(let i=0; i<8; i++) particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, '#8d5524'));
            } else {
                 for(let i=0; i<3; i++) particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, '#5e3a1b'));
            }
        }

        draw(ctx) {
            if (!this.initialized) return;
            ctx.save();
            ctx.translate(this.shakeOffset, 0);
            if (this.isHit) {
                 ctx.filter = 'sepia(1) saturate(100) hue-rotate(-50deg) contrast(2)';
            }
            let img = this.alive ? bearAliveImg : bearDeadImg;
            if (img.complete && img.naturalWidth > 0) {
                 ctx.drawImage(img, this.x, this.y, this.w, this.h);
            }
            ctx.restore();
        }
    }

    class Dog extends Entity {
        constructor() {
            super(1300, 1000, 7);
            this.state = 'sleeping'; 
            this.wakeTimer = 0;
            this.hasGivenPoints = false;
            this.targetX1 = 1377;
            this.targetY1 = 1060;
            this.targetX2 = 1333;
            this.targetY2 = 1047;
            this.initialized = false;
        }

        update() {
            super.update();
            if (this.state === 'awake') {
                this.wakeTimer--;
                if (this.wakeTimer <= 0) this.state = 'sleeping';
            }
            let img = this.state === 'sleeping' ? dogSleepImg : dogAwakeImg;
            if (img.complete && img.naturalWidth > 0) {
                this.w = img.naturalWidth; 
                this.h = img.naturalHeight;
                const targetX = this.state === 'sleeping' ? this.targetX1 : this.targetX2;
                const targetY = this.state === 'sleeping' ? this.targetY1 : this.targetY2;
                this.x = targetX - this.w;
                this.y = targetY - this.h;
                this.initialized = true;
            }
        }

        onHit() {
            this.state = 'awake';
            this.wakeTimer = 100; 
            if (!this.hasGivenPoints) {
                this.hasGivenPoints = true;
                state.score += 15;
                updateUI();
                for(let i=0; i<8; i++) particles.push(new Particle(this.x + this.w/2, this.y, '#c28848'));
            } else {
                for(let i=0; i<3; i++) particles.push(new Particle(this.x + this.w/2, this.y, '#c28848'));
            }
        }

        draw(ctx) {
            if (!this.initialized) return;
            let img = this.state === 'sleeping' ? dogSleepImg : dogAwakeImg;
            if (img.complete && img.naturalWidth > 0) {
                 ctx.drawImage(img, this.x, this.y, this.w, this.h);
            } 
            
            if (this.state === 'sleeping' && Math.floor(Date.now() / 800) % 2 === 0) {
                ctx.fillStyle = 'white';
                ctx.font = '30px monospace'; 
                ctx.fillText('Zzz', 1017, 925);
            }
        }
    }

    class Enemy extends Entity {
        constructor(type) {
            super(-400, 0, 8); 
            this.type = type;
            this.direction = Math.random() > 0.5 ? 1 : -1;
            this.baseY = 900 + Math.random() * 200; 
            this.hopPhase = Math.random() * Math.PI * 2;
            
            this.initialized = false;
            this.dying = false; 
            this.hitFilter = ''; 
            
            if (type === 'snowman') {
                this.img = snowmanImg;
                this.speedBase = 1.5;
                this.scoreVal = 100;
                this.color = '#fff';
            } else if (type === 'elf') {
                this.img = elfImg;
                this.speedBase = 3.0;
                this.scoreVal = 200;
                this.color = '#52b748';
                this.bounceOffset = 0;
            } else if (type === 'santa') {
                this.img = santaImg;
                this.speedBase = 3.6;
                this.scoreVal = 1000;
                this.color = '#d32f2f';
            } else if (type === 'reindeer') {
                this.img = reindeerImg;
                this.speedBase = 2;
                this.scoreVal = 50;
                this.color = '#8B4513';
                this.bounceOffset = 0;
            }
            
            this.speed = (Math.random() * 1.5 + this.speedBase) * FX_SCALE * 0.6; 

            this.y = 0;
            if (this.direction === 1) {
                this.x = -200; 
            } else {
                this.x = canvas.width + 200;
            }
        }

        update() {
            super.update();
            
            if (!this.initialized && this.img.complete && this.img.naturalWidth > 0) {
                this.w = this.img.naturalWidth;
                this.h = this.img.naturalHeight;
                this.y = this.baseY - this.h;
                
                if (this.direction === 1) {
                    this.x = -this.w - 50;
                } else {
                    this.x = canvas.width + 50;
                }
                
                this.initialized = true;
            }
            
            if (!this.initialized) return;

            if (!this.dying) {
                this.x += this.speed * this.direction;

                if (this.type === 'elf' || this.type === 'reindeer') {
                    const time = Date.now() / 100 + this.hopPhase;
                    const absSin = Math.abs(Math.sin(time));
                    const bounceHeight = (this.type === 'reindeer') ? 15 * FX_SCALE : 50 * FX_SCALE;

                    this.bounceOffset = absSin * bounceHeight;
                    this.y = (this.baseY - this.h) - this.bounceOffset;
                    this.bounceFactor = absSin;
                }

                if ((this.direction === 1 && this.x > canvas.width) ||
                    (this.direction === -1 && this.x < -this.w)) {
                    this.markedForDeletion = true;
                }
            } else {
                if (this.hitTimer <= 0) {
                    this.markedForDeletion = true;
                }
            }
        }

        onHit() {
            if (this.dying) return; 
            
            state.score += this.scoreVal;
            updateUI();
            
            this.hitFilter = HIT_FILTERS[Math.floor(Math.random() * HIT_FILTERS.length)];
            
            this.isHit = true;
            this.hitTimer = 5; 
            this.dying = true; 

            for(let i=0; i<15; i++) {
                particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, this.color));
            }
        }

        draw(ctx) {
            if (!this.initialized) return;
            
            if (this.isHit) {
                ctx.save();
                ctx.filter = this.hitFilter;
            } else {
                ctx.fillStyle = this.color;
            }

            if (this.type === 'snowman') {
                const hopCycle = Math.sin((Date.now() / 400) + this.hopPhase); 
                const absHop = Math.abs(hopCycle); 
                const jumpHeight = (20 * FX_SCALE) * absHop;
                let stretch = 1.0 + (absHop * 0.2);
                let squash = 1.0 - (absHop * 0.1); 
                if (absHop < 0.2) { stretch = 0.9; squash = 1.1; }

                const drawX = this.x;
                const drawY = (this.baseY - this.h) - jumpHeight;
                
                const scaledW = this.w * squash;
                const scaledH = this.h * stretch;
                const offsetX = (this.w - scaledW) / 2;
                const offsetY = (this.h - scaledH); 
                ctx.drawImage(this.img, this.x + offsetX, (this.dying ? this.y : drawY) + offsetY, scaledW, scaledH);

            } else if (this.type === 'santa') {
                 ctx.save();
                 const cx = this.x + this.w / 2;
                 const cy = this.y + this.h / 2;
                 ctx.translate(cx, cy);
                 if (!this.dying) ctx.rotate(this.x * 0.015); 
                 ctx.drawImage(this.img, -this.w/2, -this.h/2, this.w, this.h);
                 ctx.restore();

            } else if (this.type === 'elf' || this.type === 'reindeer') {
                let stretch = 1.0 + (this.bounceFactor * 0.15); 
                let squash = 1.0 - (this.bounceFactor * 0.1); 
                if (this.bounceFactor < 0.2) { stretch = 0.85; squash = 1.15; }

                const finalW = this.w * squash;
                const finalH = this.h * stretch;
                const cx = this.x + this.w / 2;
                const cy = this.y + this.h; 

                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(this.direction, 1);
                
                ctx.drawImage(this.img, -finalW/2, -finalH, finalW, finalH);
                ctx.restore();
            }

            if (this.isHit) {
                ctx.restore(); 
            }
        }
    }

    // --- SYSTEM FUNCTIONS ---

    function setupMenu() {
        // Clear buttons if any
        entities = entities.filter(e => !(e instanceof ButtonTarget) && !(e instanceof ImageButtonTarget));
        
        // Add Logo & Buttons
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        // Start Button (Moved down, gap reduced)
        entities.push(new ButtonTarget(cx, cy + 180, "START GAME", startGame));
        // Highscore Button (Closer to Start)
        entities.push(new ButtonTarget(cx, cy + 280, "HIGHSCORE", showHighscores));
    }

    function startGame() {
        state.current = STATES.PLAYING;
        state.score = 0;
        state.time = 60;
        updateUI();
        
        // Clear buttons
        entities = entities.filter(e => !(e instanceof ButtonTarget) && !(e instanceof ImageButtonTarget));
        
        // Reset Props (Refill gifts, fix windows, etc if we want full reset)
        // For now, simpler to just re-init everything
        initLevel();
        
        spawnLoop();
        startTimer();
    }

    function checkHighscore() {
        // Simple logic: Is score in top 10?
        if (state.highscores.length < 10) return true;
        return state.score > state.highscores[state.highscores.length - 1].score;
    }

    function showGameOver() {
        state.current = STATES.GAMEOVER;
        state.enteringInitials = false;
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        // Check Highscore
        if (checkHighscore()) {
            state.enteringInitials = true;
            state.playerInitials = "";
        }

        // Add 3 Icon Buttons
        const iconY = cy + 300;
        const spacing = 70 + 120; // Width + gap
        const startX = cx - spacing; // Center the group of 3 (Left, Center, Right)

        // 1. Highscore
        entities.push(new ImageButtonTarget(startX, iconY, iconHighscore, showHighscores));
        // 2. Retry
        entities.push(new ImageButtonTarget(startX + spacing, iconY, iconRetry, startGame));
        // 3. Menu
        entities.push(new ImageButtonTarget(startX + spacing * 2, iconY, iconMenu, () => {
            setupMenu();
            state.current = STATES.MENU;
        }));
    }

    function showHighscores() {
        state.current = STATES.HIGHSCORE;
        // Clear Buttons
        entities = entities.filter(e => !(e instanceof ButtonTarget) && !(e instanceof ImageButtonTarget));
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        // Back Button
        entities.push(new ButtonTarget(cx, cy + 350, "BACK", () => {
            setupMenu();
            state.current = STATES.MENU;
        }));
    }

    // Input Handling for Initials
    window.addEventListener('keydown', (e) => {
        if (state.current === STATES.GAMEOVER && state.enteringInitials) {
            if (e.key.length === 1 && e.key.match(/[a-zA-Z0-9]/)) {
                if (state.playerInitials.length < 3) {
                    state.playerInitials += e.key.toUpperCase();
                }
            } else if (e.key === 'Backspace') {
                state.playerInitials = state.playerInitials.slice(0, -1);
            }

            // Save on 3rd char? Or maybe enter key. User said "When player has entered 3 initials it saves"
            if (state.playerInitials.length === 3) {
                // Save logic
                state.highscores.push({
                    name: state.playerInitials,
                    score: state.score
                });
                state.highscores.sort((a,b) => b.score - a.score);
                if (state.highscores.length > 10) state.highscores.pop();
                
                state.enteringInitials = false; // Stop editing
                // Don't jump, stay here.
            }
        }
    });

    function initLevel() {
        entities.length = 0;
        particles.length = 0;
        snowballs.length = 0;
        
        // --- Props Placement (Fixed Layering) ---
        // 0: Tree
        // 1: Gifts
        // 2: Fire, Windows
        // 2.5: Snow
        // 3: Sill, Wreath
        // 4: Frames
        // 5: Socks
        // 6: Lights
        // 7: Dog, Bear
        // 8: Enemies
        // 100: UI

        // Layer 0: Tree
        entities.push(new Tree()); 

        // Layer 1: Gifts
        const giftCoords = [
            {x: 101, y: 879}, {x: 218, y: 884}, {x: 335, y: 891}, {x: 448, y: 891}, {x: 551, y: 903}
        ];
        for(let i=0; i<5; i++) {
            entities.push(new Gift(i, giftCoords[i].x, giftCoords[i].y, giftImgs[i]));
        }
        
        // Layer 2: Fire, Windows
        entities.push(new Fire());
        const winCoords = [
            {x: 1382, y: 255}, {x: 1612, y: 255}, {x: 1382, y: 432}, {x: 1610, y: 432}
        ];
        winCoords.forEach((pos, i) => {
            entities.push(new WindowPane(windowImgs.normal[i], windowImgs.broken[i], pos.x, pos.y)); 
        });

        // Layer 2.5: Snow
        entities.push(new SnowTank());

        // Layer 3: Sill, Wreath
        const sill = new SimpleProp(sillImg, 1317, 232, 3);
        sill.collidable = false;
        entities.push(sill);
        entities.push(new Wreath());

        // Layer 4: Frames
        const frameCoords = [
            {x: 637, y: 436}, {x: 722, y: 421}, {x: 827, y: 468},
            {x: 974, y: 459}, {x: 1095, y: 400}, {x: 1190, y: 473}
        ];
        frameCoords.forEach((pos, i) => {
            entities.push(new SimpleProp(frameImgs[i], pos.x, pos.y, 4, (x, y, w, h) => {
                for(let k=0; k<8; k++) particles.push(new Particle(x+w/2, y+h/2, '#8b4513', 10, 3));
            }));
        });

        // Layer 5: Socks
        const sockCoords = [
            {x: 737, y: 517, c: '#ff0000'}, {x: 898, y: 519, c: '#00ff00'}, {x: 1073, y: 516, c: '#0000ff'}
        ];
        sockCoords.forEach((data, i) => {
            entities.push(new SimpleProp(sockImgs[i], data.x, data.y, 5, (x, y, w, h) => {
                for(let k=0; k<12; k++) particles.push(new Particle(x+w/2, y+h/2, data.c, 6, 6));
            }));
        });

        // Layer 6: Lights
        const lightColors = [
            '#ffff00', '#00ff00', '#ff0000', '#40e0d0', '#00ff00', 
            '#ff0000', '#ffff00', '#00ff00', '#40e0d0', '#ff0000'
        ];
        const lightCoords = [
            {x: 610, y: 168}, {x: 711, y: 135}, {x: 807, y: 93}, {x: 911, y: 35}, {x: 1105, y: 51},
            {x: 1226, y: 103}, {x: 1328, y: 156}, {x: 1432, y: 180}, {x: 1558, y: 170}, {x: 1686, y: 170}
        ];
        lightCoords.forEach((pos, i) => {
            entities.push(new SimpleProp(lightImgs[i], pos.x, pos.y, 6, (x, y, w, h) => {
                for(let k=0; k<6; k++) particles.push(new Particle(x+w/2, y+h/2, lightColors[i], 20, 2));
            }));
        });

        // Layer 7: Dog, Bear
        entities.push(new Dog());
        entities.push(new Bear());
    }

    function init() {
        initLevel();
        setupMenu(); // Start in Menu
        
        state.current = STATES.MENU;
        
        requestAnimationFrame(gameLoop);
    }

    function spawnLoop() {
        if (state.current !== STATES.PLAYING) return;
        
        const r = Math.random();
        
        if (r > 0.95) {
            spawnReindeerTrain(9);
        } else if (r > 0.88) {
            entities.push(new Enemy('santa'));
        } else if (r > 0.55) {
            entities.push(new Enemy('elf'));
        } else {
            entities.push(new Enemy('snowman'));
        }

        setTimeout(spawnLoop, Math.random() * 1500 + 500);
    }

    function spawnReindeerTrain(count) {
        if (count <= 0) return;
        let deer = new Enemy('reindeer');
        deer.direction = 1; 
        deer.x = -150; 
        deer.y = 900; 
        deer.baseY = 980; 
        entities.push(deer);

        setTimeout(() => spawnReindeerTrain(count - 1), 400); 
    }

    function checkCollision(impactX, impactY) {
        const hitOrder = [...entities].sort((a,b) => {
            if (b.layer !== a.layer) return b.layer - a.layer;
            return b.getZ() - a.getZ();
        });
        
        let hitSomething = false;

        for (let ent of hitOrder) {
            if (ent.collidable && ent.checkHit(impactX, impactY)) {
                ent.onHit();
                ent.isHit = true;
                ent.hitTimer = 5;
                hitSomething = true;
                break; 
            }
        }
    }

    function startTimer() {
        const timerId = setInterval(() => {
            if (state.current !== STATES.PLAYING) {
                clearInterval(timerId);
                return;
            }
            state.time--;
            updateUI();
            if (state.time <= 0) showGameOver();
        }, 1000);
    }

    function updateUI() {
        document.getElementById('score-display').innerText = state.score.toString().padStart(4, '0');
        document.getElementById('time-display').innerText = state.time;
    }

    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    });

    canvas.addEventListener('mousedown', () => {
        // Shooting allowed in MENU, PLAYING, and GAMEOVER to hit buttons/props
        snowballs.push(new Snowball(mouse.x, mouse.y));
    });

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Background
        if (bgImg.complete && bgImg.naturalWidth > 0) {
            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#65554a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#3e2f26'; ctx.fillRect(0, canvas.height - 200, canvas.width, 200);
        }

        // UPDATE LOOP
        for (let i = entities.length - 1; i >= 0; i--) {
            let ent = entities[i];
            ent.update();
            if (ent.markedForDeletion) entities.splice(i, 1);
        }

        // DRAW LOOP (Game Entities)
        entities.sort((a, b) => {
            if (a.layer !== b.layer) return a.layer - b.layer;
            return a.getZ() - b.getZ();
        });

        for (let ent of entities) {
            ent.draw(ctx);
        }

        // DRAW OVERLAYS FOR MENU / GAMEOVER / HIGHSCORE
        if (state.current === STATES.MENU || state.current === STATES.GAMEOVER || state.current === STATES.HIGHSCORE) {
            // Dark Cherry Overlay
            ctx.fillStyle = 'rgba(44, 14, 28, 0.69)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Re-Draw UI Buttons on top of overlay (Filter entities for Layer 100)
            const uiButtons = entities.filter(e => e.layer === 100);
            uiButtons.forEach(btn => btn.draw(ctx));

            // Draw Logo in Menu
            if (state.current === STATES.MENU && logoImg.complete) {
                const lw = logoImg.naturalWidth;
                const lh = logoImg.naturalHeight;
                const lx = (canvas.width - lw) / 2;
                const ly = 250; // Dropped Logo Down
                ctx.drawImage(logoImg, lx, ly);
            }

            // Draw Text for Game Over
            if (state.current === STATES.GAMEOVER) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '100px "Press Start 2P"'; 
                ctx.textAlign = 'center';
                ctx.fillText("TIME'S UP!", canvas.width/2, canvas.height/2 - 200); 
                
                // Score Display Logic
                if (state.enteringInitials) {
                    // New Highscore Input Mode
                    ctx.font = '40px "Press Start 2P"'; 
                    ctx.fillText("HIGH SCORE", canvas.width/2, canvas.height/2 - 40);
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '120px "Press Start 2P"';
                    const scoreText = state.score.toString();
                    
                    // Layout: INITIALS <INPUT>
                    ctx.font = '40px "Press Start 2P"';
                    ctx.fillStyle = '#fff';
                    ctx.fillText("INITIALS", canvas.width/2 - 200, canvas.height/2 + 100);
                    
                    // Input Box
                    ctx.fillStyle = '#222';
                    ctx.fillRect(canvas.width/2 + 20, canvas.height/2 + 50, 300, 80);
                    
                    // Typed Letters
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '60px "Press Start 2P"';
                    ctx.fillText(state.playerInitials + (Date.now() % 1000 < 500 ? "_" : ""), canvas.width/2 + 170, canvas.height/2 + 110);

                } else {
                    // Standard Result
                    ctx.font = '40px "Press Start 2P"'; 
                    ctx.fillText("FINAL SCORE", canvas.width/2, canvas.height/2 - 40);
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '120px "Press Start 2P"';
                    ctx.fillText(state.score.toString(), canvas.width/2, canvas.height/2 + 100); 
                }
            }

            // Draw Highscores
            if (state.current === STATES.HIGHSCORE) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '100px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText("HIGHSCORE", canvas.width/2, 200);

                ctx.font = '40px "Press Start 2P"';
                const startY = 350;
                const lineHeight = 60;
                
                // Header
                ctx.fillStyle = '#ffd700';
                ctx.fillText("RANK   SCORE   NAME", canvas.width/2, 300);
                
                ctx.fillStyle = '#ffffff';
                for(let i=0; i<10; i++) {
                    const entry = state.highscores[i] || {score: 0, name: '---'};
                    const y = startY + i * lineHeight;
                    
                    // Rank
                    ctx.textAlign = 'right';
                    ctx.fillText((i+1) + ".", canvas.width/2 - 300, y);
                    
                    // Score
                    ctx.textAlign = 'center';
                    ctx.fillText(entry.score.toString().padStart(6, '0'), canvas.width/2, y);
                    
                    // Name
                    ctx.textAlign = 'left';
                    ctx.fillText(entry.name, canvas.width/2 + 200, y);
                }
            }
        }

        // Particles & Snowballs always on top
        for (let i = snowballs.length - 1; i >= 0; i--) {
            let s = snowballs[i];
            s.update();
            s.draw(ctx);
            if (s.markedForDeletion) snowballs.splice(i, 1);
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw(ctx);
            if (p.life <= 0) particles.splice(i, 1);
        }

        // Crosshair
        if (crosshairImg.complete && crosshairImg.naturalWidth > 0) {
             const cw = crosshairImg.naturalWidth; // No Scale
             const ch = crosshairImg.naturalHeight; // No Scale
             ctx.drawImage(crosshairImg, mouse.x - cw/2, mouse.y - ch/2, cw, ch);
        } else {
            // Fallback to old crosshair
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 40, 0, Math.PI*2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mouse.x - 50, mouse.y); ctx.lineTo(mouse.x + 50, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - 50); ctx.lineTo(mouse.x, mouse.y + 50);
            ctx.stroke();
            ctx.fillStyle = 'red'; ctx.fillRect(mouse.x - 2, mouse.y - 2, 4, 4);
        }

        requestAnimationFrame(gameLoop);
    }

    init();

</script>
</body>
</html>
